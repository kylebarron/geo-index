{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"geoindex-rs","text":"<p>Fast, memory-efficient 2D spatial indexes for Python.</p> <p>This documentation is for the Python bindings. Refer here for the Rust crate documentation.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install geoindex-rs\n</code></pre> <p>or with Conda:</p> <pre><code>conda install geoindex-rs\n</code></pre>"},{"location":"#api","title":"API","text":""},{"location":"#kdtree","title":"<code>KDTree</code>","text":""},{"location":"#kdtreefrom_interleaved","title":"<code>KDTree.from_interleaved</code>","text":"<p>Construct a KDTree from a 2D numpy array of <code>x</code> and <code>y</code>. This must have two dimensions, with the second dimension having length two.</p>"},{"location":"#kdtreefrom_separated","title":"<code>KDTree.from_separated</code>","text":"<p>Construct a KDTree from two separated 1D numpy arrays of <code>x</code> and <code>y</code>. Each array must have one dimension and both arrays must have the same length.</p>"},{"location":"#kdtreerange","title":"<code>KDTree.range</code>","text":"<p>Search the index for items within a given bounding box.</p> <p>Arguments:</p> <ul> <li><code>min_x</code>: float</li> <li><code>min_y</code>: float</li> <li><code>max_x</code>: float</li> <li><code>max_y</code>: float</li> </ul> <p>Returns indices of found items</p>"},{"location":"#kdtreewithin","title":"<code>KDTree.within</code>","text":"<p>Search the index for items within a given radius.</p> <ul> <li><code>qx</code> (<code>float</code>): x value of query point</li> <li><code>qy</code> (<code>float</code>): y value of query point</li> <li><code>r</code> (<code>float</code>): radius</li> </ul> <p>Returns indices of found items</p>"},{"location":"api/kdtree/","title":"KDTree","text":""},{"location":"api/kdtree/#geoindex_rs.kdtree","title":"geoindex_rs.kdtree","text":""},{"location":"api/kdtree/#geoindex_rs.kdtree.ArrayLike","title":"ArrayLike  <code>module-attribute</code>","text":"<pre><code>ArrayLike = Union[ndarray, ArrowArrayExportable, Buffer]\n</code></pre> <p>A type alias for accepted input to the <code>KDTreeBuilder.add</code> method.</p> <p>Accepted input includes numpy arrays, Arrow arrays, and C-contiguous buffer protocol input.</p>"},{"location":"api/kdtree/#geoindex_rs.kdtree.IndexLike","title":"IndexLike  <code>module-attribute</code>","text":"<pre><code>IndexLike = Union[ndarray, ArrowArrayExportable, Buffer, KDTree]\n</code></pre> <p>A type alias for accepted input as a KDTree.</p>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTree","title":"KDTree","text":"<p>               Bases: <code>Buffer</code></p> <p>A fast, memory-efficient, zero-copy-compatible, 2D KDTree.</p> <p>Use <code>KDTreeBuilder</code>, and then call <code>finish</code> to construct this.</p> <p>This uses a binary-stable memory layout under the hood. So you can write the index to disk, then later load it and perform queries on it.</p> <p>This class implements the Python buffer protocol, so you can pass it to the Python <code>bytes</code> constructor to copy the underlying binary memory into a Python <code>bytes</code> object.</p>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTreeBuilder","title":"KDTreeBuilder","text":"<p>A builder class to create a KDTree.</p> <p>Example:</p> <pre><code>import numpy as np\nfrom geoindex_rs import kdtree as kd\n\nbuilder = kd.KDTreeBuilder(3)\nx = np.arange(0, 3)\ny = np.arange(2, 5)\nbuilder.add(x, y)\ntree = builder.finish()\n</code></pre>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTreeBuilder.__init__","title":"__init__","text":"<pre><code>__init__(num_items: int, node_size: int = 64, coord_type: Literal['float32', 'float64'] = 'float64') -&gt; None\n</code></pre> <p>Initialize a KDTree with the given parameters.</p> <p>This will provision memory for the KDTree, to be filled in the <code>add</code> method.</p> <p>Parameters:</p> <ul> <li> <code>num_items</code>               (<code>int</code>)           \u2013            <p>The number of items in the tree</p> </li> <li> <code>node_size</code>               (<code>int</code>, default:                   <code>64</code> )           \u2013            <p>The node size of the tree. Defaults to 64.</p> </li> <li> <code>coord_type</code>               (<code>Literal['float32', 'float64']</code>, default:                   <code>'float64'</code> )           \u2013            <p>The coordinate type to use in the tree. Currently only float32 and float64 are permitted. Defaults to \"float64\".</p> </li> </ul>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTreeBuilder.add","title":"add","text":"<pre><code>add(x: ArrayLike, y: ArrayLike | None = None) -&gt; Array\n</code></pre> <p>Insert points in this KDTree.</p> <p>There are multiple ways to call this method:</p> <ul> <li>Two numpy or Arrow numeric arrays, passed as <code>x</code>, <code>y</code>.</li> <li>A 2D numpy array, with shape <code>(N, 2)</code>. It must be C-contiguous.</li> <li>One argument with an Arrow array of type FixedSizeList or Struct. The   FixedSizeListArray must have a <code>list_size</code> of 2, and the <code>StructArray</code> must   have 2 children, ordered <code>x</code> and <code>y</code>.</li> </ul> <p>In this case, all other parameters should be left as <code>None</code>.</p> <p>Note</p> <p>Most of the time, you should call <code>add</code> only once. This function is vectorized, and you should avoid calling it in a loop with a few rows of data at a time.</p> <p>In some cases, it may be useful to call this in a loop, such as if the input geometries do not all fit in memory at once.</p> <p>It's important to add arrays at a time. This should usually not be called in a loop.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>ArrayLike</code>)           \u2013            <p>array-like input</p> </li> <li> <code>y</code>               (<code>ArrayLike | None</code>, default:                   <code>None</code> )           \u2013            <p>array-like input. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Arrow array with the insertion index of each element, which provides a lookup back into the original data.</p> </li> </ul>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTreeBuilder.finish","title":"finish","text":"<pre><code>finish() -&gt; KDTree\n</code></pre> <p>Sort the internal index and convert this class to a KDTree instance.</p> <p>Returns:</p> <ul> <li> <code>KDTree</code>           \u2013            <p>An immutable KDTree instance, which can be used for spatial queries.</p> </li> </ul>"},{"location":"api/kdtree/#geoindex_rs.kdtree.range","title":"range","text":"<pre><code>range(index: IndexLike, min_x: int | float, min_y: int | float, max_x: int | float, max_y: int | float) -&gt; Array\n</code></pre> <p>Search a KDTree for elements intersecting the provided bounding box.</p> <p>Results are the insertion indexes of items that match the query.</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>IndexLike</code>)           \u2013            <p>the KDTree to search</p> </li> <li> <code>min_x</code>               (<code>int | float</code>)           \u2013            <p>The <code>min_x</code> coordinate of the query bounding box</p> </li> <li> <code>min_y</code>               (<code>int | float</code>)           \u2013            <p>The <code>min_y</code> coordinate of the query bounding box</p> </li> <li> <code>max_x</code>               (<code>int | float</code>)           \u2013            <p>The <code>max_x</code> coordinate of the query bounding box</p> </li> <li> <code>max_y</code>               (<code>int | float</code>)           \u2013            <p>The <code>max_y</code> coordinate of the query bounding box</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Arrow array with the insertion indexes of query results.</p> </li> </ul>"},{"location":"api/kdtree/#geoindex_rs.kdtree.within","title":"within","text":"<pre><code>within(index: IndexLike, qx: int | float, qy: int | float, r: int | float) -&gt; Array\n</code></pre> <p>Search a KDTree for elements within the given distance of the query point.</p> <p>Results are the insertion indexes of items that match the query.</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>IndexLike</code>)           \u2013            <p>the KDTree to search</p> </li> <li> <code>qx</code>               (<code>int | float</code>)           \u2013            <p>The <code>x</code> coordinate of the query point</p> </li> <li> <code>qy</code>               (<code>int | float</code>)           \u2013            <p>The <code>y</code> coordinate of the query point</p> </li> <li> <code>r</code>               (<code>int | float</code>)           \u2013            <p>The radius from the query point to use for searching.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Arrow array with the insertion indexes of query results.</p> </li> </ul>"},{"location":"api/rtree/","title":"RTree","text":""},{"location":"api/rtree/#geoindex_rs.rtree","title":"geoindex_rs.rtree","text":""},{"location":"api/rtree/#geoindex_rs.rtree.ArrayLike","title":"ArrayLike  <code>module-attribute</code>","text":"<pre><code>ArrayLike = Union[ndarray, ArrowArrayExportable, Buffer]\n</code></pre> <p>A type alias for accepted input to the <code>RTreeBuilder.add</code> method.</p> <p>Accepted input includes numpy arrays, Arrow arrays, and C-contiguous buffer protocol input.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.IndexLike","title":"IndexLike  <code>module-attribute</code>","text":"<pre><code>IndexLike = Union[ndarray, ArrowArrayExportable, Buffer, RTree]\n</code></pre> <p>A type alias for accepted input as an RTree.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.RTree","title":"RTree","text":"<p>               Bases: <code>Buffer</code></p> <p>A fast, memory-efficient, zero-copy-compatible, 2D RTree.</p> <p>Use <code>RTreeBuilder</code>, and then call <code>finish</code> to construct this.</p> <p>This uses a binary-stable memory layout under the hood. So you can write the index to disk, then later load it and perform queries on it.</p> <p>This class implements the Python buffer protocol, so you can pass it to the Python <code>bytes</code> constructor to copy the underlying binary memory into a Python <code>bytes</code> object.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.RTree.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata: RTreeMetadata\n</code></pre> <p>Access the metadata instance of this RTree.</p> <p>Use this to infer the number of items or nodes in this RTree.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeBuilder","title":"RTreeBuilder","text":"<p>A builder class to create an RTree.</p> <p>Example:</p> <pre><code>import numpy as np\nfrom geoindex_rs import rtree as rt\n\nbuilder = rt.RTreeBuilder(3)\nmin_x = np.arange(0, 3)\nmin_y = np.arange(0, 3)\nmax_x = np.arange(2, 5)\nmax_y = np.arange(2, 5)\nbuilder.add(min_x, min_y, max_x, max_y)\ntree = builder.finish()\n</code></pre>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeBuilder.__init__","title":"__init__","text":"<pre><code>__init__(num_items: int, node_size: int = 16, coord_type: Literal['float32', 'float64'] = 'float64') -&gt; None\n</code></pre> <p>Initialize an RTree with the given parameters.</p> <p>This will provision memory for the RTree, to be filled in the <code>add</code> method.</p> <p>Parameters:</p> <ul> <li> <code>num_items</code>               (<code>int</code>)           \u2013            <p>The number of items in the tree</p> </li> <li> <code>node_size</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>The node size of the tree. Defaults to 16.</p> </li> <li> <code>coord_type</code>               (<code>Literal['float32', 'float64']</code>, default:                   <code>'float64'</code> )           \u2013            <p>The coordinate type to use in the tree. Currently only float32 and float64 are permitted. Defaults to None.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeBuilder.add","title":"add","text":"<pre><code>add(min_x: ArrayLike, min_y: ArrayLike | None = None, max_x: ArrayLike | None = None, max_y: ArrayLike | None = None) -&gt; Array\n</code></pre> <p>Insert bounding boxes in this RTree.</p> <p>There are multiple ways to call this method:</p> <ul> <li>Four numpy or Arrow numeric arrays, passed as <code>min_x</code>, <code>min_y</code>, <code>max_x</code>, <code>max_y</code>.</li> <li>A 2D numpy array, with shape <code>(N, 4)</code>. It must be C-contiguous.</li> <li>One argument with an Arrow array of type FixedSizeList or Struct. The   FixedSizeListArray must have a <code>list_size</code> of 4, and the <code>StructArray</code> must   have four children, ordered <code>min_x</code>, <code>min_y</code>, <code>max_x</code>, <code>max_y</code>.</li> </ul> <p>In this case, all other parameters should be left as <code>None</code>.</p> <p>Example: Adding shapely geometries</p> <pre><code>import numpy as np\nimport shapely\nfrom geoindex_rs import rtree as rt\n\n# Shapely array of geometries, such as from GeoPandas\ngeometries = [...]\n\nbuilder = rt.RTreeBuilder(len(geometries))\n\n# Find the bounding box of each geometry\nbounds = shapely.bounds(geometries)\nbuilder.add(bounds)\ntree = builder.finish()\n\nresults = rt.neighbors(tree, 5, 5)\nassert results.to_pylist() == [2, 1, 0]\n</code></pre> <p>Note</p> <p>Most of the time, you should call <code>add</code> only once. This function is vectorized, and you should avoid calling it in a loop with a few rows of data at a time.</p> <p>In some cases, it may be useful to call this in a loop, such as if the input geometries do not all fit in memory at once.</p> <p>It's important to add arrays at a time. This should usually not be called in a loop.</p> <p>Parameters:</p> <ul> <li> <code>min_x</code>               (<code>ArrayLike</code>)           \u2013            <p>array-like input</p> </li> <li> <code>min_y</code>               (<code>ArrayLike | None</code>, default:                   <code>None</code> )           \u2013            <p>array-like input. Defaults to None.</p> </li> <li> <code>max_x</code>               (<code>ArrayLike | None</code>, default:                   <code>None</code> )           \u2013            <p>array-like input. Defaults to None.</p> </li> <li> <code>max_y</code>               (<code>ArrayLike | None</code>, default:                   <code>None</code> )           \u2013            <p>array-like input. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Arrow array with the insertion index of each element, which provides a lookup back into the original data.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeBuilder.finish","title":"finish","text":"<pre><code>finish(method: Literal['hilbert', 'str'] = 'hilbert') -&gt; RTree\n</code></pre> <p>Sort the internal index and convert this class to an RTree instance.</p> <p>Parameters:</p> <ul> <li> <code>method</code>               (<code>Literal['hilbert', 'str']</code>, default:                   <code>'hilbert'</code> )           \u2013            <p>The method used for sorting the RTree. <code>\"hilbert\"</code> will use a Hilbert Curve for sorting; <code>\"str\"</code> will use the Sort-Tile-Recursive algorithm. Defaults to <code>\"hilbert\"</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RTree</code>           \u2013            <p>An immutable RTree instance, which can be used for spatial queries.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata","title":"RTreeMetadata","text":"<p>Common metadata to describe an RTree.</p> <p>This can be used to know the number of items, node informatino, or total byte size of an RTree.</p> <p>Additionally, this can be used to know how much memory an RTree would use with the given number of items and node size. An RTree with 1 million items and a node size of 20 would take up 38 MiB.</p> <pre><code>from geoindex_rs import rtree as rt\n\nmetadata = rt.RTreeMetadata(num_items=1_000_000, node_size=20)\nassert metadata.num_bytes == 37_894_796\n</code></pre>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata.node_size","title":"node_size  <code>property</code>","text":"<pre><code>node_size: int\n</code></pre> <p>The maximum number of items per node.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata.num_bytes","title":"num_bytes  <code>property</code>","text":"<pre><code>num_bytes: int\n</code></pre> <p>The number of bytes that an RTree with this metadata would have.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata.num_items","title":"num_items  <code>property</code>","text":"<pre><code>num_items: int\n</code></pre> <p>The number of items indexed in the tree.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata.num_levels","title":"num_levels  <code>property</code>","text":"<pre><code>num_levels: int\n</code></pre> <p>The number of levels in the tree.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata.num_nodes","title":"num_nodes  <code>property</code>","text":"<pre><code>num_nodes: int\n</code></pre> <p>The total number of nodes at all levels in the tree.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata.__init__","title":"__init__","text":"<pre><code>__init__(num_items: int, node_size: int = 16, coord_type: Literal['float32', 'float64'] = 'float64') -&gt; None\n</code></pre> <p>Create a new RTreeMetadata given a number of items and node size.</p> <p>Parameters:</p> <ul> <li> <code>num_items</code>               (<code>int</code>)           \u2013            <p>The number of items in the tree</p> </li> <li> <code>node_size</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>The node size of the tree. Defaults to 16.</p> </li> <li> <code>coord_type</code>               (<code>Literal['float32', 'float64']</code>, default:                   <code>'float64'</code> )           \u2013            <p>The coordinate type to use in the tree. Currently only float32 and float64 are permitted. Defaults to None.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata.from_index","title":"from_index  <code>classmethod</code>","text":"<pre><code>from_index(index: IndexLike) -&gt; RTreeMetadata\n</code></pre> <p>Create from an existing RTree buffer.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.boxes_at_level","title":"boxes_at_level","text":"<pre><code>boxes_at_level(index: IndexLike, level: int) -&gt; Array\n</code></pre> <p>Access the raw bounding box data contained in the RTree at a given tree level.</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>IndexLike</code>)           \u2013            <p>the RTree to search.</p> </li> <li> <code>level</code>               (<code>int</code>)           \u2013            <p>The level of the tree to read from. Level 0 is the base of the tree. Each integer higher is one level higher of the tree.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Arrow FixedSizeListArray containing the bounding box coordinates.</p> <p>The returned array is a a zero-copy view from Rust. Note that it will keep the entire index memory alive until the returned array is garbage collected.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.neighbors","title":"neighbors","text":"<pre><code>neighbors(index: IndexLike, x: int | float, y: int | float, *, max_results: int | None, max_distance: int | float | None) -&gt; Array\n</code></pre> <p>Search items in order of distance from the given point.</p> <p>Example:</p> <pre><code>import numpy as np\nfrom geoindex_rs import rtree as rt\n\nbuilder = rt.RTreeBuilder(3)\nmin_x = np.arange(0, 3)\nmin_y = np.arange(0, 3)\nmax_x = np.arange(2, 5)\nmax_y = np.arange(2, 5)\nbuilder.add(min_x, min_y, max_x, max_y)\ntree = builder.finish()\n\nresults = rt.neighbors(tree, 5, 5)\nassert results.to_pylist() == [2, 1, 0]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>IndexLike</code>)           \u2013            <p>the RTree to search.</p> </li> <li> <code>x</code>               (<code>int | float</code>)           \u2013            <p>the <code>x</code> coordinate of the query point</p> </li> <li> <code>y</code>               (<code>int | float</code>)           \u2013            <p>the <code>y</code> coordinate of the query point</p> </li> <li> <code>max_results</code>               (<code>int | None</code>)           \u2013            <p>The maximum number of results to search. If not provided, all results (within <code>max_distance</code>) will be returned.</p> </li> <li> <code>max_distance</code>               (<code>int | float | None</code>)           \u2013            <p>The maximum distance from the query point to search. If not provided, all results (up to <code>max_results</code>) will be returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Arrow array with the insertion indexes of query results.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.partition_boxes","title":"partition_boxes","text":"<pre><code>partition_boxes(index: IndexLike) -&gt; RecordBatch\n</code></pre> <p>Extract the geometries of the spatial partitions from an RTree.</p> <p>In order for these boxes to be zero-copy from Rust, they are returned as a FixedSizeListArray, where each element has 4 items.</p> <p>Note</p> <p>While <code>partitions</code> returns a <code>RecordBatch</code> that has a length of the number of items, this returns a <code>RecordBatch</code> with a length matching the number of partitions.</p> <p>This is equivalent to calling <code>boxes_at_level(1)</code>, plus the <code>partition_id</code> column, which is a monotonically-increasing integer column.</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>IndexLike</code>)           \u2013            <p>the RTree to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RecordBatch</code>           \u2013            <p>An Arrow <code>RecordBatch</code> with two columns: <code>boxes</code> and <code>partition_ids</code>. <code>boxes</code> stores the box geometry of each partition and <code>partition_ids</code> refers to the partition each row belongs to.</p> <p>The <code>boxes</code> column is constructed as a zero-copy view on the internal boxes data. The <code>partition_id</code> column will be <code>uint16</code> type if there are less than 65,536 partitions; otherwise it will be <code>uint32</code> type.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.partitions","title":"partitions","text":"<pre><code>partitions(index: IndexLike) -&gt; RecordBatch\n</code></pre> <p>Extract the spatial partitions from an RTree.</p> <p>This can be used to find the sorted groups for spatially partitioning the original data, such as when writing spatially-partitioned GeoParquet.</p> <p>Note</p> <p>Currently, this always uses the lowest level of the tree when inferring partitioning. Thus, for large input you may want to use the largest node size possible (<code>65535</code>) for constructing a tree for use in spatial partitioning.</p> <p>Future work may allow higher levels of the tree to be used for partitioning.</p> <p>Example:</p> <pre><code>import numpy as np\nfrom geoindex_rs import rtree as rt\n\n# Create a new builder with space for 100 million boxes\nnum_items = 100_000_000\nbuilder = rt.RTreeBuilder(num_items, 65535)\nmin_x = np.random.uniform(-100, -10, num_items)\nmin_y = np.random.uniform(-50, -10, num_items)\nmax_x = np.random.uniform(10, 100, num_items)\nmax_y = np.random.uniform(10, 50, num_items)\nbuilder.add(min_x, min_y, max_x, max_y)\ntree = builder.finish()\n\npartitions = rt.partitions(tree)\n# There are 1526 partitioned groups\nassert partitions[\"partition_id\"][-1].as_py() == 1525\n</code></pre> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>IndexLike</code>)           \u2013            <p>the RTree to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RecordBatch</code>           \u2013            <p>An Arrow <code>RecordBatch</code> with two columns: <code>indices</code> and <code>partition_ids</code>. <code>indices</code> refers to the insertion index of each row and <code>partition_ids</code> refers to the partition each row belongs to.</p> <p>The <code>indices</code> column is constructed as a zero-copy view on the provided index. Therefore, the <code>indices</code> array will have type <code>uint16</code> if the tree has fewer than 16,384 items; otherwise it will have type <code>uint32</code>.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.search","title":"search","text":"<pre><code>search(index: IndexLike, min_x: int | float, min_y: int | float, max_x: int | float, max_y: int | float) -&gt; Array\n</code></pre> <p>Search an RTree for elements intersecting the provided bounding box.</p> <p>Results are the insertion indexes of items that match the query.</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>IndexLike</code>)           \u2013            <p>the RTree to search</p> </li> <li> <code>min_x</code>               (<code>int | float</code>)           \u2013            <p>The <code>min_x</code> coordinate of the query bounding box</p> </li> <li> <code>min_y</code>               (<code>int | float</code>)           \u2013            <p>The <code>min_y</code> coordinate of the query bounding box</p> </li> <li> <code>max_x</code>               (<code>int | float</code>)           \u2013            <p>The <code>max_x</code> coordinate of the query bounding box</p> </li> <li> <code>max_y</code>               (<code>int | float</code>)           \u2013            <p>The <code>max_y</code> coordinate of the query bounding box</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Arrow array with the insertion indexes of query results.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.tree_join","title":"tree_join","text":"<pre><code>tree_join(left: IndexLike, right: IndexLike) -&gt; RecordBatch\n</code></pre> <p>Find the overlapping elements of two RTrees.</p> <p>This is the first part of a spatial join: to find which elements from two different data sources potentially intersect.</p> <p>Note that this only evaluates intersection of the bounding boxes in the tree. Assuming that these bounding boxes represent actual vector geometries, the result of this join are candidates. Any pairs present implies that the bounding boxes of those two indices intersect. Any pairs not present implies that the bounding boxes of those two indices cannot intersect, and therefore the represented geometries cannot intersect.</p> <p>This returns an Arrow <code>RecordBatch</code> with positional indexes from the left and right trees. The <code>RecordBatch</code> has two <code>uint32</code> columns named <code>\"left\"</code> and <code>\"right\"</code>.</p> <p>Parameters:</p> <ul> <li> <code>left</code>               (<code>IndexLike</code>)           \u2013            <p>The \"left\" spatial index for the join.</p> </li> <li> <code>right</code>               (<code>IndexLike</code>)           \u2013            <p>The \"right\" spatial index for the join.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RecordBatch</code>           \u2013            <p>An Arrow <code>RecordBatch</code> with the positional indexes of intersecting tree elements.</p> </li> </ul>"}]}