{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"geoindex-rs","text":"<p>Fast, memory-efficient, zero-copy spatial indexes for Python.</p> <p>This documentation is for the Python bindings. Refer here for the Rust crate documentation.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>An R-tree and k-d tree written in Rust, compiled for Python.</li> <li>Fast. The Rust core and immutability lends the spatial indexes to be very fast. Additionally, building the indexes accepts vectorized Numpy or Arrow input.</li> <li>Memory efficient. The index is fully packed, meaning that all nodes are at full capacity (except for the last node at each tree level). This means the RTree and k-d tree use less memory.</li> <li>Bounded memory. For any given number of items and node size, you can infer the total memory used by the RTree or KDTree.</li> <li>Multiple R-tree sorting methods. Currently, hilbert and sort-tile-recursive (STR) sorting methods are implemented.</li> <li>ABI-stable: the index is contained in a single buffer, compatible with the <code>flatbush</code> and <code>kdbush</code> JavaScript libraries. Being ABI-stable means that the spatial index can be persisted for later use or shared zero-copy between Rust and Python.</li> <li>Supports float64 or float32 coordinates: for 2x memory savings, use float32 coordinates in the spatial index.</li> </ul>"},{"location":"#install","title":"Install","text":"<pre><code>pip install geoindex-rs\n</code></pre> <p>or with Conda:</p> <pre><code>conda install geoindex-rs\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>Building an RTree and searching for nearest neighbors.</p> <pre><code>import numpy as np\nfrom geoindex_rs import rtree as rt\n\n# Three bounding boxes\nmin_x = np.arange(0, 3)\nmin_y = np.arange(0, 3)\nmax_x = np.arange(2, 5)\nmax_y = np.arange(2, 5)\n\n# When creating the builder, the total number of items must be passed\nbuilder = rt.RTreeBuilder(num_items=3)\n\n# Add the bounding boxes to the builder\nbuilder.add(min_x, min_y, max_x, max_y)\n\n# Consume the builder (sorting the index) and create the RTree.\ntree = builder.finish()\n\n# Find the nearest neighbors in the RTree to the point (5, 5)\nresults = rt.neighbors(tree, 5, 5)\n\n# For performance, results are returned as an Arrow array.\nassert results.to_pylist() == [2, 1, 0]\n</code></pre> <p>Building a KDTree and searching within a bounding box.</p> <pre><code>import numpy as np\nfrom geoindex_rs import kdtree as kd\n\n# Three points: (0, 2), (1, 3), (2, 4)\nx = np.arange(0, 3)\ny = np.arange(2, 5)\n\n# When creating the builder, the total number of items must be passed\nbuilder = kd.KDTreeBuilder(3)\n\n# Add the points to the builder\nbuilder.add(x, y)\n\n# Consume the builder (sorting the index) and create the KDTree.\ntree = builder.finish()\n\n# Search within this bounding box:\nresults = kd.range(tree, 2, 4, 7, 9)\n\n# For performance, results are returned as an Arrow array.\nassert results.to_pylist() == [2]\n</code></pre>"},{"location":"#persisting-the-spatial-index","title":"Persisting the spatial index","text":"<p>The <code>RTree</code> and <code>KDTree</code> classes implement the Python buffer protocol, so you can pass an instance of the index directly to <code>bytes</code> to copy the underlying spatial index into a buffer. Then you can save that buffer somewhere, load it again, and use it directly for queries!</p> <pre><code>import numpy as np\nfrom geoindex_rs import rtree as rt\n\nmin_x = np.arange(0, 3)\nmin_y = np.arange(0, 3)\nmax_x = np.arange(2, 5)\nmax_y = np.arange(2, 5)\n\nbuilder = rt.RTreeBuilder(num_items=3)\nbuilder.add(min_x, min_y, max_x, max_y)\ntree = builder.finish()\n\n# Copy to a Python bytes object\ncopied_tree = bytes(tree)\n\n# The entire RTree is contained within this 144 byte buffer\nassert len(copied_tree) == 144\n\n# We can use the bytes object (or anything else implementing the Python buffer\n# protocol) directly in searches\nresults = rt.neighbors(copied_tree, 5, 5)\nassert results.to_pylist() == [2, 1, 0]\n</code></pre>"},{"location":"#drawbacks","title":"Drawbacks","text":"<ul> <li>Trees are immutable. After creating the index, items can no longer be added or removed.</li> <li>Only two-dimensional indexes is supported. This can still be used with higher-dimensional input data as long as it's fine to only index two of the dimensions.</li> <li>Queries return insertion indexes into the input set, so you must manage your own collections.</li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#020-2025-01-06","title":"[0.2.0] - 2025-01-06","text":""},{"location":"CHANGELOG/#new-features","title":"New Features","text":"<ul> <li>Support for nearest neighbor searching on RTrees with <code>neighbors</code>.</li> <li>Join two RTrees together with <code>tree_join</code>, finding their overlapping elements. This is the first part of a spatial join: to find which elements from two different data sources potentially intersect.</li> <li>Extract partitioning structure from the underlying RTree with <code>partitions</code> and see the partition geometries with <code>partition_boxes</code>.</li> <li>Expose <code>RTreeMetadata</code> and <code>KDTreeMetadata</code>. These allow you to infer the memory usage a tree would incur.</li> <li>Access the internal boxes within the RTree for inspecting the tree internals with <code>boxes_at_level</code>.</li> <li>Implement the buffer protocol on <code>RTree</code> and <code>KDTree</code>. This means you can copy the underlying buffer to Python with <code>bytes(tree)</code>.</li> </ul>"},{"location":"CHANGELOG/#breaking","title":"Breaking","text":"<ul> <li>Move RTree and KDTree query functions to standalone global functions. This   makes it easier to persist index buffers and reuse them later, because the   query functions work on any object supporting the buffer protocol.</li> <li>Create \"builder\" classes: <code>RTreeBuilder</code> and <code>KDTreeBuilder</code>. Having these as separate classes allows for iteratively adding the coordinates for an RTree or KDTree. This is useful when the source geometries are larger than fits in memory.</li> </ul>"},{"location":"CHANGELOG/#documentation","title":"Documentation","text":"<ul> <li>New documentation website for Python bindings.</li> </ul>"},{"location":"CHANGELOG/#010-2024-03-26","title":"[0.1.0] - 2024-03-26","text":"<ul> <li>Initial public release.</li> </ul>"},{"location":"api/kdtree/","title":"KDTree","text":""},{"location":"api/kdtree/#geoindex_rs.kdtree","title":"geoindex_rs.kdtree","text":""},{"location":"api/kdtree/#geoindex_rs.kdtree.ArrayLike","title":"ArrayLike  <code>module-attribute</code>","text":"<pre><code>ArrayLike = Union[ndarray, ArrowArrayExportable, Buffer]\n</code></pre> <p>A type alias for accepted input to the <code>KDTreeBuilder.add</code> method.</p> <p>Accepted input includes numpy arrays, Arrow arrays, and C-contiguous buffer protocol input.</p>"},{"location":"api/kdtree/#geoindex_rs.kdtree.IndexLike","title":"IndexLike  <code>module-attribute</code>","text":"<pre><code>IndexLike = Union[ndarray, ArrowArrayExportable, Buffer, KDTree]\n</code></pre> <p>A type alias for accepted input as a KDTree.</p>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTree","title":"KDTree","text":"<p>               Bases: <code>Buffer</code></p> <p>A fast, memory-efficient, zero-copy-compatible, 2D KDTree.</p> <p>Use <code>KDTreeBuilder</code>, and then call <code>finish</code> to construct this.</p> <p>This uses a binary-stable memory layout under the hood. So you can write the index to disk, then later load it and perform queries on it.</p> <p>This class implements the Python buffer protocol, so you can pass it to the Python <code>bytes</code> constructor to copy the underlying binary memory into a Python <code>bytes</code> object.</p>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTreeBuilder","title":"KDTreeBuilder","text":"<p>A builder class to create a KDTree.</p> <p>Example:</p> <pre><code>import numpy as np\nfrom geoindex_rs import kdtree as kd\n\nbuilder = kd.KDTreeBuilder(3)\nx = np.arange(0, 3)\ny = np.arange(2, 5)\nbuilder.add(x, y)\ntree = builder.finish()\n\nresults = kd.range(tree, 2, 4, 7, 9)\nassert results.to_pylist() == [2]\n</code></pre>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTreeBuilder.__init__","title":"__init__","text":"<pre><code>__init__(\n    num_items: int,\n    node_size: int = 64,\n    coord_type: Literal[\"float32\", \"float64\"] = \"float64\",\n) -&gt; None\n</code></pre> <p>Initialize a KDTree with the given parameters.</p> <p>This will provision memory for the KDTree, to be filled in the <code>add</code> method.</p> <p>Parameters:</p> <ul> <li> <code>num_items</code>               (<code>int</code>)           \u2013            <p>The number of items in the tree</p> </li> <li> <code>node_size</code>               (<code>int</code>, default:                   <code>64</code> )           \u2013            <p>The node size of the tree. Defaults to 64.</p> </li> <li> <code>coord_type</code>               (<code>Literal['float32', 'float64']</code>, default:                   <code>'float64'</code> )           \u2013            <p>The coordinate type to use in the tree. Currently only float32 and float64 are permitted. Defaults to \"float64\".</p> </li> </ul>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTreeBuilder.add","title":"add","text":"<pre><code>add(x: ArrayLike, y: ArrayLike | None = None) -&gt; Array\n</code></pre> <p>Insert points in this KDTree.</p> <p>There are multiple ways to call this method:</p> <ul> <li>Two numpy or Arrow numeric arrays, passed as <code>x</code>, <code>y</code>.</li> <li>A 2D numpy array, with shape <code>(N, 2)</code>. It must be C-contiguous.</li> <li>One argument with an Arrow array of type FixedSizeList or Struct. The   FixedSizeListArray must have a <code>list_size</code> of 2, and the <code>StructArray</code> must   have 2 children, ordered <code>x</code> and <code>y</code>.</li> </ul> <p>In this case, all other parameters should be left as <code>None</code>.</p> <p>Note</p> <p>Most of the time, you should call <code>add</code> only once. This function is vectorized, and you should avoid calling it in a loop with a few rows of data at a time.</p> <p>In some cases, it may be useful to call this in a loop, such as if the input geometries do not all fit in memory at once.</p> <p>It's important to add arrays at a time. This should usually not be called in a loop.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>ArrayLike</code>)           \u2013            <p>array-like input</p> </li> <li> <code>y</code>               (<code>ArrayLike | None</code>, default:                   <code>None</code> )           \u2013            <p>array-like input. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Arrow array with the insertion index of each element, which provides a lookup back into the original data.</p> <p>This can be converted to a <code>pyarrow.Array</code> by passing to <code>pyarrow.array</code>.</p> </li> </ul>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTreeBuilder.finish","title":"finish","text":"<pre><code>finish() -&gt; KDTree\n</code></pre> <p>Sort the internal index and convert this class to a KDTree instance.</p> <p>Returns:</p> <ul> <li> <code>KDTree</code>           \u2013            <p>An immutable KDTree instance, which can be used for spatial queries.</p> </li> </ul>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTreeMetadata","title":"KDTreeMetadata","text":"<p>Common metadata to describe a KDTree.</p> <p>This can be used to know the number of items, node information, or total byte size of a KDTree.</p> <p>Additionally, this can be used to know how much memory a KDTree would use with the given number of items and node size. A KDTree with 1 million items and a node size of 64 (the default) would take up 20 MiB.</p> <pre><code>from geoindex_rs import kdtree as kd\n\nmetadata = kd.KDTreeMetadata(num_items=1_000_000, node_size=64)\nassert metadata.num_bytes == 20_000_008\n</code></pre>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTreeMetadata.node_size","title":"node_size  <code>property</code>","text":"<pre><code>node_size: int\n</code></pre> <p>The maximum number of items per node.</p>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTreeMetadata.num_bytes","title":"num_bytes  <code>property</code>","text":"<pre><code>num_bytes: int\n</code></pre> <p>The number of bytes that a KDTree with this metadata would have.</p>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTreeMetadata.num_items","title":"num_items  <code>property</code>","text":"<pre><code>num_items: int\n</code></pre> <p>The number of items indexed in the tree.</p>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTreeMetadata.__init__","title":"__init__","text":"<pre><code>__init__(\n    num_items: int,\n    node_size: int = 64,\n    coord_type: Literal[\"float32\", \"float64\"] = \"float64\",\n) -&gt; None\n</code></pre> <p>Create a new KDTreeMetadata given a number of items and node size.</p> <p>Parameters:</p> <ul> <li> <code>num_items</code>               (<code>int</code>)           \u2013            <p>The number of items in the tree</p> </li> <li> <code>node_size</code>               (<code>int</code>, default:                   <code>64</code> )           \u2013            <p>The node size of the tree. Defaults to 16.</p> </li> <li> <code>coord_type</code>               (<code>Literal['float32', 'float64']</code>, default:                   <code>'float64'</code> )           \u2013            <p>The coordinate type to use in the tree. Currently only float32 and float64 are permitted. Defaults to None.</p> </li> </ul>"},{"location":"api/kdtree/#geoindex_rs.kdtree.KDTreeMetadata.from_index","title":"from_index  <code>classmethod</code>","text":"<pre><code>from_index(index: IndexLike) -&gt; KDTreeMetadata\n</code></pre> <p>Create from an existing KDTree buffer.</p>"},{"location":"api/kdtree/#geoindex_rs.kdtree.range","title":"range","text":"<pre><code>range(\n    index: IndexLike,\n    min_x: int | float,\n    min_y: int | float,\n    max_x: int | float,\n    max_y: int | float,\n) -&gt; Array\n</code></pre> <p>Search a KDTree for elements intersecting the provided bounding box.</p> <p>Results are the insertion indexes of items that match the query.</p> <p>Example:</p> <pre><code>import numpy as np\nfrom geoindex_rs import kdtree as kd\n\nbuilder = kd.KDTreeBuilder(3)\nx = np.arange(0, 3)\ny = np.arange(2, 5)\nbuilder.add(x, y)\ntree = builder.finish()\n\nresults = kd.range(tree, 2, 4, 7, 9)\nassert results.to_pylist() == [2]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>IndexLike</code>)           \u2013            <p>the KDTree to search.</p> </li> <li> <code>min_x</code>               (<code>int | float</code>)           \u2013            <p>The <code>min_x</code> coordinate of the query bounding box.</p> </li> <li> <code>min_y</code>               (<code>int | float</code>)           \u2013            <p>The <code>min_y</code> coordinate of the query bounding box.</p> </li> <li> <code>max_x</code>               (<code>int | float</code>)           \u2013            <p>The <code>max_x</code> coordinate of the query bounding box.</p> </li> <li> <code>max_y</code>               (<code>int | float</code>)           \u2013            <p>The <code>max_y</code> coordinate of the query bounding box.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>A uint32-typed Arrow array with the insertion indexes of query results.</p> </li> </ul>"},{"location":"api/kdtree/#geoindex_rs.kdtree.within","title":"within","text":"<pre><code>within(\n    index: IndexLike, qx: int | float, qy: int | float, r: int | float\n) -&gt; Array\n</code></pre> <p>Search a KDTree for elements within the given distance of the query point.</p> <p>Results are the insertion indexes of items that match the query.</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>IndexLike</code>)           \u2013            <p>the KDTree to search.</p> </li> <li> <code>qx</code>               (<code>int | float</code>)           \u2013            <p>The <code>x</code> coordinate of the query point.</p> </li> <li> <code>qy</code>               (<code>int | float</code>)           \u2013            <p>The <code>y</code> coordinate of the query point.</p> </li> <li> <code>r</code>               (<code>int | float</code>)           \u2013            <p>The radius from the query point to use for searching.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>A uint32-typed Arrow array with the insertion indexes of query results.</p> </li> </ul>"},{"location":"api/rtree/","title":"RTree","text":""},{"location":"api/rtree/#geoindex_rs.rtree","title":"geoindex_rs.rtree","text":""},{"location":"api/rtree/#geoindex_rs.rtree.ArrayLike","title":"ArrayLike  <code>module-attribute</code>","text":"<pre><code>ArrayLike = Union[ndarray, ArrowArrayExportable, Buffer]\n</code></pre> <p>A type alias for accepted input to the <code>RTreeBuilder.add</code> method.</p> <p>Accepted input includes numpy arrays, Arrow arrays, and C-contiguous buffer protocol input.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.IndexLike","title":"IndexLike  <code>module-attribute</code>","text":"<pre><code>IndexLike = Union[ndarray, ArrowArrayExportable, Buffer, RTree]\n</code></pre> <p>A type alias for accepted input as an RTree.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.RTree","title":"RTree","text":"<p>               Bases: <code>Buffer</code></p> <p>A fast, memory-efficient, zero-copy-compatible, 2D RTree.</p> <p>Use <code>RTreeBuilder</code>, and then call <code>finish</code> to construct this.</p> <p>This uses a binary-stable memory layout under the hood. So you can write the index to disk, then later load it and perform queries on it.</p> <p>This class implements the Python buffer protocol, so you can pass it to the Python <code>bytes</code> constructor to copy the underlying binary memory into a Python <code>bytes</code> object.</p> <pre><code>import numpy as np\nfrom geoindex_rs import rtree as rt\n\nmin_x = np.arange(0, 3)\nmin_y = np.arange(0, 3)\nmax_x = np.arange(2, 5)\nmax_y = np.arange(2, 5)\n\nbuilder = rt.RTreeBuilder(num_items=3)\nbuilder.add(min_x, min_y, max_x, max_y)\ntree = builder.finish()\n\n# Copy to a Python bytes object\ncopied_tree = bytes(tree)\n\n# The entire RTree is contained within this 144 byte buffer\nassert len(copied_tree) == 144\n\n# We can use the bytes object (or anything else implementing the Python buffer\nprotocol) directly in searches\nresults = rt.neighbors(copied_tree, 5, 5)\nassert results.to_pylist() == [2, 1, 0]\n</code></pre>"},{"location":"api/rtree/#geoindex_rs.rtree.RTree.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata: RTreeMetadata\n</code></pre> <p>Access the metadata instance of this RTree.</p> <p>Use this to infer the number of items or nodes in this RTree.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeBuilder","title":"RTreeBuilder","text":"<p>A builder class to create an RTree.</p> <p>Example:</p> <pre><code>import numpy as np\nfrom geoindex_rs import rtree as rt\n\nbuilder = rt.RTreeBuilder(3)\nmin_x = np.arange(0, 3)\nmin_y = np.arange(0, 3)\nmax_x = np.arange(2, 5)\nmax_y = np.arange(2, 5)\nbuilder.add(min_x, min_y, max_x, max_y)\ntree = builder.finish()\n</code></pre>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeBuilder.__init__","title":"__init__","text":"<pre><code>__init__(\n    num_items: int,\n    node_size: int = 16,\n    coord_type: Literal[\"float32\", \"float64\"] = \"float64\",\n) -&gt; None\n</code></pre> <p>Initialize an RTree with the given parameters.</p> <p>This will provision memory for the RTree, to be filled in the <code>add</code> method.</p> <p>Parameters:</p> <ul> <li> <code>num_items</code>               (<code>int</code>)           \u2013            <p>The number of items in the tree</p> </li> <li> <code>node_size</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>The node size of the tree. Defaults to 16.</p> </li> <li> <code>coord_type</code>               (<code>Literal['float32', 'float64']</code>, default:                   <code>'float64'</code> )           \u2013            <p>The coordinate type to use in the tree. Currently only float32 and float64 are permitted. Defaults to None.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeBuilder.add","title":"add","text":"<pre><code>add(\n    min_x: ArrayLike,\n    min_y: ArrayLike | None = None,\n    max_x: ArrayLike | None = None,\n    max_y: ArrayLike | None = None,\n) -&gt; Array\n</code></pre> <p>Insert bounding boxes in this RTree.</p> <p>There are multiple ways to call this method:</p> <ul> <li>Four numpy or Arrow numeric arrays, passed as <code>min_x</code>, <code>min_y</code>, <code>max_x</code>, <code>max_y</code>.</li> <li>A 2D numpy array, with shape <code>(N, 4)</code>. It must be C-contiguous.</li> <li>One argument with an Arrow array of type FixedSizeList or Struct. The   FixedSizeListArray must have a <code>list_size</code> of 4, and the <code>StructArray</code> must   have four children, ordered <code>min_x</code>, <code>min_y</code>, <code>max_x</code>, <code>max_y</code>.</li> </ul> <p>In this case, all other parameters should be left as <code>None</code>.</p> <p>Example: Adding shapely geometries</p> <pre><code>import numpy as np\nimport shapely\nfrom geoindex_rs import rtree as rt\n\n# Shapely array of geometries, such as from GeoPandas\ngeometries = [...]\n\nbuilder = rt.RTreeBuilder(len(geometries))\n\n# Find the bounding box of each geometry\nbounds = shapely.bounds(geometries)\nbuilder.add(bounds)\ntree = builder.finish()\n\nresults = rt.neighbors(tree, 5, 5)\nassert results.to_pylist() == [2, 1, 0]\n</code></pre> <p>Note</p> <p>Most of the time, you should call <code>add</code> only once. This function is vectorized, and you should avoid calling it in a loop with a few rows of data at a time.</p> <p>In some cases, it may be useful to call this in a loop, such as if the input geometries do not all fit in memory at once.</p> <p>It's important to add arrays at a time. This should usually not be called in a loop.</p> <p>Parameters:</p> <ul> <li> <code>min_x</code>               (<code>ArrayLike</code>)           \u2013            <p>array-like input. If this is the only provided input, it should represent the entire bounding box, as described above. Otherwise, pass four separate parameters.</p> </li> <li> <code>min_y</code>               (<code>ArrayLike | None</code>, default:                   <code>None</code> )           \u2013            <p>array-like input. Defaults to None.</p> </li> <li> <code>max_x</code>               (<code>ArrayLike | None</code>, default:                   <code>None</code> )           \u2013            <p>array-like input. Defaults to None.</p> </li> <li> <code>max_y</code>               (<code>ArrayLike | None</code>, default:                   <code>None</code> )           \u2013            <p>array-like input. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Arrow array with the insertion index of each element, which provides a lookup back into the original data.</p> <p>This can be converted to a <code>pyarrow.Array</code> by passing to <code>pyarrow.array</code>.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeBuilder.finish","title":"finish","text":"<pre><code>finish(method: Literal['hilbert', 'str'] = 'hilbert') -&gt; RTree\n</code></pre> <p>Sort the internal index and convert this class to an RTree instance.</p> <p>Parameters:</p> <ul> <li> <code>method</code>               (<code>Literal['hilbert', 'str']</code>, default:                   <code>'hilbert'</code> )           \u2013            <p>The method used for sorting the RTree. Defaults to <code>\"hilbert\"</code>.</p> <ul> <li><code>\"hilbert\"</code> will use a Hilbert Curve for sorting.</li> <li><code>\"str\"</code> will use the Sort-Tile-Recursive algorithm.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>RTree</code>           \u2013            <p>An immutable RTree instance, which can be used for spatial queries.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata","title":"RTreeMetadata","text":"<p>Common metadata to describe an RTree.</p> <p>This can be used to know the number of items, node information, or total byte size of an RTree.</p> <p>Additionally, this can be used to know how much memory an RTree would use with the given number of items and node size. An RTree with 1 million items and a node size of 20 would take up 38 MiB.</p> <pre><code>from geoindex_rs import rtree as rt\n\nmetadata = rt.RTreeMetadata(num_items=1_000_000, node_size=20)\nassert metadata.num_bytes == 37_894_796\n</code></pre>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata.node_size","title":"node_size  <code>property</code>","text":"<pre><code>node_size: int\n</code></pre> <p>The maximum number of items per node.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata.num_bytes","title":"num_bytes  <code>property</code>","text":"<pre><code>num_bytes: int\n</code></pre> <p>The number of bytes that an RTree with this metadata would have.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata.num_items","title":"num_items  <code>property</code>","text":"<pre><code>num_items: int\n</code></pre> <p>The number of items indexed in the tree.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata.num_levels","title":"num_levels  <code>property</code>","text":"<pre><code>num_levels: int\n</code></pre> <p>The number of levels in the tree.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata.num_nodes","title":"num_nodes  <code>property</code>","text":"<pre><code>num_nodes: int\n</code></pre> <p>The total number of nodes at all levels in the tree.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata.__init__","title":"__init__","text":"<pre><code>__init__(\n    num_items: int,\n    node_size: int = 16,\n    coord_type: Literal[\"float32\", \"float64\"] = \"float64\",\n) -&gt; None\n</code></pre> <p>Create a new RTreeMetadata given a number of items and node size.</p> <p>Parameters:</p> <ul> <li> <code>num_items</code>               (<code>int</code>)           \u2013            <p>The number of items in the tree</p> </li> <li> <code>node_size</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>The node size of the tree. Defaults to 16.</p> </li> <li> <code>coord_type</code>               (<code>Literal['float32', 'float64']</code>, default:                   <code>'float64'</code> )           \u2013            <p>The coordinate type to use in the tree. Currently only float32 and float64 are permitted. Defaults to None.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.RTreeMetadata.from_index","title":"from_index  <code>classmethod</code>","text":"<pre><code>from_index(index: IndexLike) -&gt; RTreeMetadata\n</code></pre> <p>Create from an existing RTree buffer.</p>"},{"location":"api/rtree/#geoindex_rs.rtree.boxes_at_level","title":"boxes_at_level","text":"<pre><code>boxes_at_level(index: IndexLike, level: int, *, copy: bool = False) -&gt; Array\n</code></pre> <p>Access the raw bounding box data contained in the RTree at a given tree level.</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>IndexLike</code>)           \u2013            <p>the RTree to search.</p> </li> <li> <code>level</code>               (<code>int</code>)           \u2013            <p>The level of the tree to read from. Level 0 is the base of the tree. Each integer higher is one level higher of the tree.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>copy</code>               (<code>bool</code>)           \u2013            <p>if True, make a copy of the data from the underlying RTree instead of viewing it directly. Making a copy can be preferred if you'd like to delete the index itself to save memory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Arrow FixedSizeListArray containing the bounding box coordinates.</p> <p>If <code>copy</code> is <code>False</code>, the returned array is a a zero-copy view from Rust. Note that it will keep the entire index memory alive until the returned array is garbage collected.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.neighbors","title":"neighbors","text":"<pre><code>neighbors(\n    index: IndexLike,\n    x: int | float,\n    y: int | float,\n    *,\n    max_results: int | None,\n    max_distance: int | float | None,\n) -&gt; Array\n</code></pre> <p>Search items in order of distance from the given point.</p> <p>Example:</p> <pre><code>import numpy as np\nfrom geoindex_rs import rtree as rt\n\nbuilder = rt.RTreeBuilder(3)\nmin_x = np.arange(0, 3)\nmin_y = np.arange(0, 3)\nmax_x = np.arange(2, 5)\nmax_y = np.arange(2, 5)\nbuilder.add(min_x, min_y, max_x, max_y)\ntree = builder.finish()\n\nresults = rt.neighbors(tree, 5, 5)\nassert results.to_pylist() == [2, 1, 0]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>IndexLike</code>)           \u2013            <p>the RTree to search.</p> </li> <li> <code>x</code>               (<code>int | float</code>)           \u2013            <p>the <code>x</code> coordinate of the query point</p> </li> <li> <code>y</code>               (<code>int | float</code>)           \u2013            <p>the <code>y</code> coordinate of the query point</p> </li> <li> <code>max_results</code>               (<code>int | None</code>)           \u2013            <p>The maximum number of results to search. If not provided, all results (within <code>max_distance</code>) will be returned.</p> </li> <li> <code>max_distance</code>               (<code>int | float | None</code>)           \u2013            <p>The maximum distance from the query point to search. If not provided, all results (up to <code>max_results</code>) will be returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Arrow array with the insertion indexes of query results.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.partition_boxes","title":"partition_boxes","text":"<pre><code>partition_boxes(index: IndexLike, *, copy: bool = False) -&gt; RecordBatch\n</code></pre> <p>Extract the geometries of the spatial partitions from an RTree.</p> <p>In order for these boxes to be zero-copy from Rust, they are returned as a FixedSizeListArray, where each element has 4 items.</p> <p>Note</p> <p>While <code>partitions</code> returns a <code>RecordBatch</code> that has a length of the number of items, this returns a <code>RecordBatch</code> with a length matching the number of partitions.</p> <p>This is equivalent to calling <code>boxes_at_level(1)</code>, plus the <code>partition_id</code> column, which is a monotonically-increasing integer column.</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>IndexLike</code>)           \u2013            <p>the RTree to use.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>copy</code>               (<code>bool</code>)           \u2013            <p>if True, make a copy of the data from the underlying RTree instead of viewing it directly. Making a copy can be preferred if you'd like to delete the index itself to save memory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RecordBatch</code>           \u2013            <p>An Arrow <code>RecordBatch</code> with two columns: <code>boxes</code> and <code>partition_ids</code>. <code>boxes</code> stores the box geometry of each partition and <code>partition_ids</code> refers to the partition each row belongs to.</p> <p>If <code>copy</code> is <code>False</code>, the <code>boxes</code> column is constructed as a zero-copy view on the internal boxes data. The <code>partition_id</code> column will be <code>uint16</code> type if there are less than 65,536 partitions; otherwise it will be <code>uint32</code> type.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.partitions","title":"partitions","text":"<pre><code>partitions(index: IndexLike, *, copy=False) -&gt; RecordBatch\n</code></pre> <p>Extract the spatial partitions from an RTree.</p> <p>This can be used to find the sorted groups for spatially partitioning the original data, such as when writing spatially-partitioned GeoParquet.</p> <p>Note</p> <p>Currently, this always uses the lowest level of the tree when inferring partitioning. Thus, for large input you may want to use the largest node size possible (<code>65535</code>) for constructing a tree for use in spatial partitioning.</p> <p>Future work may allow higher levels of the tree to be used for partitioning.</p> <p>Example:</p> <pre><code>import numpy as np\nfrom geoindex_rs import rtree as rt\n\n# Create a new builder with space for 100 million boxes\nnum_items = 100_000_000\nbuilder = rt.RTreeBuilder(num_items, 65535)\nmin_x = np.random.uniform(-100, -10, num_items)\nmin_y = np.random.uniform(-50, -10, num_items)\nmax_x = np.random.uniform(10, 100, num_items)\nmax_y = np.random.uniform(10, 50, num_items)\nbuilder.add(min_x, min_y, max_x, max_y)\ntree = builder.finish()\n\npartitions = rt.partitions(tree)\n# There are 1526 partitioned groups\nassert partitions[\"partition_id\"][-1].as_py() == 1525\n</code></pre> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>IndexLike</code>)           \u2013            <p>the RTree to use.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>copy</code>           \u2013            <p>if True, make a copy of the data from the underlying RTree instead of viewing it directly. Making a copy can be preferred if you'd like to delete the index itself to save memory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RecordBatch</code>           \u2013            <p>An Arrow <code>RecordBatch</code> with two columns: <code>indices</code> and <code>partition_ids</code>. <code>indices</code> refers to the insertion index of each row and <code>partition_ids</code> refers to the partition each row belongs to.</p> <p>If <code>copy</code> is <code>False</code>, the <code>indices</code> column is constructed as a zero-copy view on the provided index. Therefore, the <code>indices</code> array will have type <code>uint16</code> if the tree has fewer than 16,384 items; otherwise it will have type <code>uint32</code>.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.search","title":"search","text":"<pre><code>search(\n    index: IndexLike,\n    min_x: int | float,\n    min_y: int | float,\n    max_x: int | float,\n    max_y: int | float,\n) -&gt; Array\n</code></pre> <p>Search an RTree for elements intersecting the provided bounding box.</p> <p>Results are the insertion indexes of items that match the query.</p> <p>Parameters:</p> <ul> <li> <code>index</code>               (<code>IndexLike</code>)           \u2013            <p>the RTree to search</p> </li> <li> <code>min_x</code>               (<code>int | float</code>)           \u2013            <p>The <code>min_x</code> coordinate of the query bounding box</p> </li> <li> <code>min_y</code>               (<code>int | float</code>)           \u2013            <p>The <code>min_y</code> coordinate of the query bounding box</p> </li> <li> <code>max_x</code>               (<code>int | float</code>)           \u2013            <p>The <code>max_x</code> coordinate of the query bounding box</p> </li> <li> <code>max_y</code>               (<code>int | float</code>)           \u2013            <p>The <code>max_y</code> coordinate of the query bounding box</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Arrow array with the insertion indexes of query results.</p> </li> </ul>"},{"location":"api/rtree/#geoindex_rs.rtree.tree_join","title":"tree_join","text":"<pre><code>tree_join(left: IndexLike, right: IndexLike) -&gt; RecordBatch\n</code></pre> <p>Find the overlapping elements of two RTrees.</p> <p>This is the first part of a spatial join: to find which elements from two different data sources potentially intersect.</p> <p>Note that this only evaluates intersection of the bounding boxes in the tree. Assuming that these bounding boxes represent actual vector geometries, the result of this join are candidates. Any pairs present implies that the bounding boxes of those two indices intersect. Any pairs not present implies that the bounding boxes of those two indices cannot intersect, and therefore the represented geometries cannot intersect.</p> <p>This returns an Arrow <code>RecordBatch</code> with positional indexes from the left and right trees. The <code>RecordBatch</code> has two <code>uint32</code> columns named <code>\"left\"</code> and <code>\"right\"</code>.</p> <p>Parameters:</p> <ul> <li> <code>left</code>               (<code>IndexLike</code>)           \u2013            <p>The \"left\" spatial index for the join.</p> </li> <li> <code>right</code>               (<code>IndexLike</code>)           \u2013            <p>The \"right\" spatial index for the join.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RecordBatch</code>           \u2013            <p>An Arrow <code>RecordBatch</code> with the positional indexes of intersecting tree elements.</p> </li> </ul>"}]}